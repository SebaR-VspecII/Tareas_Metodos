# -*- coding: utf-8 -*-
"""Tarea_8.8

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j0v4Kawvjoo94WI5BXrEiAzj5w6JCImt
"""

# ============================================================
# Tarea 8.8 - Métodos de Euler y Taylor (orden 2 y 3)
# ============================================================
# Problema:
#   y'(t) = cos(t) / sin(y(t)),   y(0) = 1,   0 <= t <= 1
#
# Se pide:
#   - Resolver numéricamente con Euler, Taylor orden 2 y 3.
#   - Comparar con la solución analítica.
#   - Graficar el error global en función de h en t=1.
#   - Analizar si los resultados son compatibles con lo esperado.
#
# Librerías permitidas: numpy, matplotlib.pyplot
# ============================================================

import numpy as np
import matplotlib.pyplot as plt


# ============================================================
# 1. DEFINICIÓN DE LA ECUACIÓN Y SOLUCIÓN ANALÍTICA
# ============================================================

def f(t, y):
    """
    Definición de la función f(t, y) del lado derecho de la EDO:
        y' = f(t, y) = cos(t) / sin(y)
    """
    return np.cos(t) / np.sin(y)


def y_analitica(t):
    """
    Solución analítica encontrada por separación de variables:
        sin(y) dy = cos(t) dt
      → -cos(y) = sin(t) + C
      Aplicando y(0)=1:  -cos(1) = 0 + C  →  C = -cos(1)
      → cos(y) = cos(1) - sin(t)
      → y(t) = arccos( cos(1) - sin(t) )
    """
    return np.arccos(np.cos(1.0) - np.sin(t))


# ============================================================
# 2. MÉTODO DE EULER
# ============================================================

def euler(f, t0, y0, h, N):
    """
    Método de Euler explícito:
        y_{n+1} = y_n + h * f(t_n, y_n)

    - Orden de precisión: 1 (error global ~ O(h))
    - Simple, pero acumula error más rápido.
    """
    t = np.linspace(t0, t0 + N * h, N + 1)  # nodos de tiempo
    y = np.zeros(N + 1)                     # arreglo solución
    y[0] = y0                               # condición inicial

    for n in range(N):
        y[n + 1] = y[n] + h * f(t[n], y[n])  # fórmula de Euler

    return t, y


# ============================================================
# 3. MÉTODO DE TAYLOR DE ORDEN 2
# ============================================================

def taylor2(f, t0, y0, h, N):
    """
    Expansión de Taylor hasta segundo orden:
        y_{n+1} = y_n + h*y' + (h^2/2)*y''
      donde:
        y' = f(t, y)
        y'' = f_t + f_y * f

    Para f(t, y) = cos(t)/sin(y):
        f_t = -sin(t)/sin(y)
        f_y = -cos(t)*cos(y)/sin^2(y)
    """
    t = np.linspace(t0, t0 + N * h, N + 1)
    y = np.zeros(N + 1)
    y[0] = y0

    for n in range(N):
        tn, yn = t[n], y[n]

        f_val = f(tn, yn)  # y'
        ft = -np.sin(tn) / np.sin(yn)
        fy = -np.cos(tn) * np.cos(yn) / np.sin(yn) ** 2

        ypp = ft + fy * f_val  # y'' según fórmula
        y[n + 1] = yn + h * f_val + (h ** 2 / 2) * ypp  # expansión hasta h²/2
    return t, y


# ============================================================
# 4. MÉTODO DE TAYLOR DE ORDEN 3
# ============================================================

def taylor3(f, t0, y0, h, N):
    """
    Expansión de Taylor hasta tercer orden:
        y_{n+1} = y_n + h*y' + (h^2/2)*y'' + (h^3/6)*y'''

    Donde:
        y'   = f
        y''  = f_t + f_y * f
        y''' = f_tt + 2*f_ty*f + f_yy*f^2 + f_y*(f_t + f_y*f)

    Las derivadas parciales de f(t, y) = cos(t)/sin(y) son:
        f_t  = -sin(t)/sin(y)
        f_y  = -cos(t)*cos(y)/sin^2(y)
        f_tt = -cos(t)/sin(y)
        f_ty =  sin(t)*cos(y)/sin^2(y)
        f_yy =  cos(t)*(sin^2(y) + 2*cos^2(y))/sin^3(y)
    """
    t = np.linspace(t0, t0 + N * h, N + 1)
    y = np.zeros(N + 1)
    y[0] = y0

    for n in range(N):
        tn, yn = t[n], y[n]
        f_val = f(tn, yn)

        # Derivadas parciales evaluadas en (t_n, y_n)
        ft = -np.sin(tn) / np.sin(yn)
        fy = -np.cos(tn) * np.cos(yn) / np.sin(yn) ** 2
        ftt = -np.cos(tn) / np.sin(yn)
        fty = np.sin(tn) * np.cos(yn) / np.sin(yn) ** 2
        fyy = np.cos(tn) * (np.sin(yn) ** 2 + 2 * np.cos(yn) ** 2) / np.sin(yn) ** 3

        # Cálculo de derivadas sucesivas de y
        ypp = ft + fy * f_val
        yppp = ftt + 2 * fty * f_val + fyy * f_val ** 2 + fy * ypp

        # Expansión de Taylor hasta h³/6
        y[n + 1] = yn + h * f_val + (h ** 2 / 2) * ypp + (h ** 3 / 6) * yppp

    return t, y


# ============================================================
# 5. BUCLE PRINCIPAL DE PRUEBA DE CONVERGENCIA
# ============================================================

# Condición inicial y rango temporal
t0, y0, tf = 0.0, 1.0, 1.0

# Diferentes tamaños de paso h
hs = np.array([0.1, 0.05, 0.025, 0.0125])

# Arreglos para guardar los errores globales en t=1
error_euler, error_t2, error_t3 = [], [], []

# Solución analítica exacta en t=1 (punto final)
y_exacto_t1 = y_analitica(tf)

# Para cada paso h se ejecutan los tres métodos
for h in hs:
    N = int((tf - t0) / h)  # número de pasos

    # Aplicar cada método numérico
    _, yE = euler(f, t0, y0, h, N)
    _, yT2 = taylor2(f, t0, y0, h, N)
    _, yT3 = taylor3(f, t0, y0, h, N)

    # Calcular errores absolutos en t = 1
    error_euler.append(abs(yE[-1] - y_exacto_t1))
    error_t2.append(abs(yT2[-1] - y_exacto_t1))
    error_t3.append(abs(yT3[-1] - y_exacto_t1))


# ============================================================
# 6. GRÁFICA DEL ERROR GLOBAL
# ============================================================

plt.figure(figsize=(8, 5))
plt.loglog(hs, error_euler, 'o-', label='Euler (orden 1)')
plt.loglog(hs, error_t2, 's-', label='Taylor orden 2')
plt.loglog(hs, error_t3, '^-', label='Taylor orden 3')
plt.xlabel('Paso h')
plt.ylabel('Error absoluto en t=1')
plt.title('Error global en t=1 vs tamaño de paso h (log-log)')
plt.grid(True, which='both', linestyle='--', alpha=0.6)
plt.legend()
plt.show()


# ============================================================
# 7. IMPRESIÓN DE RESULTADOS Y ANÁLISIS FINAL
# ============================================================

print("h\t\tError Euler\t\tError Taylor2\t\tError Taylor3")
for i, h in enumerate(hs):
    print(f"{h:.5f}\t{error_euler[i]:.3e}\t\t{error_t2[i]:.3e}\t\t{error_t3[i]:.3e}")

# -------------------------------
# Respuesta a la pregunta teórica
# -------------------------------
print("\n¿Es compatible con lo esperado?")
print("Sí. En la gráfica log-log se observa que el error disminuye siguiendo potencias de h:")
print(" • Euler (orden 1) muestra pendiente ≈ 1, es decir error proporcional a h.")
print(" • Taylor de orden 2 muestra pendiente ≈ 2, error proporcional a h².")
print(" • Taylor de orden 3 muestra pendiente ≈ 3, error proporcional a h³.")
print("Esto coincide exactamente con la teoría de convergencia de los métodos numéricos:")
print("a mayor orden del método, el error global disminuye mucho más rápido al reducir el paso h.")