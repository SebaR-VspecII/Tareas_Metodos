# -*- coding: utf-8 -*-
"""Tarea 10.3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j0v4Kawvjoo94WI5BXrEiAzj5w6JCImt
"""

import numpy as np
import matplotlib.pyplot as plt

# ============================================================
# DEFINICIÓN DEL SISTEMA
# ============================================================

def f(t, y):
    """
    Sistema de ecuaciones diferenciales.
    y es un vector [y1, y2].
    """
    y1, y2 = y
    dy1 = -4*y1 - 2*y2 + np.cos(t) + 4*np.sin(t)
    dy2 =  3*y1 +  y2 - 3*np.sin(t)
    return np.array([dy1, dy2])


# ============================================================
# IMPLEMENTACIÓN DEL MÉTODO RUNGE–KUTTA–FEHLBERG (RKF45)
# ============================================================

def rkf45_step(f, t, y, h):
    """
    Un solo paso de RKF45 para sistemas.
    Retorna:
      y4 : aproximación de orden 4
      y5 : aproximación de orden 5
    """

    # Coeficientes clásicos del método de Fehlberg
    k1 = h * f(t, y)
    k2 = h * f(t + h/4, y + k1/4)
    k3 = h * f(t + 3*h/8, y + 3*k1/32 + 9*k2/32)
    k4 = h * f(t + 12*h/13, y + 1932*k1/2197 - 7200*k2/2197 + 7296*k3/2197)
    k5 = h * f(t + h, y + 439*k1/216 - 8*k2 + 3680*k3/513 - 845*k4/4104)
    k6 = h * f(t + h/2, y - 8*k1/27 + 2*k2 - 3544*k3/2565 + 1859*k4/4104 - 11*k5/40)

    # Orden 4 (menos preciso)
    y4 = y + (25*k1/216 + 1408*k3/2565 + 2197*k4/4104 - k5/5)

    # Orden 5 (más preciso)
    y5 = y + (16*k1/135 + 6656*k3/12825 + 28561*k4/56430
              - 9*k5/50 + 2*k6/55)

    return y4, y5


def rkf45(f, t0, tf, y0, h0=0.1, tol=1e-6):
    """
    Implementación completa del método RKF45 con control adaptativo.
    """

    t = [t0]
    y = [np.array(y0)]
    h = h0

    while t[-1] < tf:

        if t[-1] + h > tf:
            h = tf - t[-1]  # ajustar último paso

        y4, y5 = rkf45_step(f, t[-1], y[-1], h)

        # Error estimado |orden5 - orden4|
        err = np.linalg.norm(y5 - y4, ord=np.inf)

        # Comparar error con tolerancia
        if err < tol:
            # Paso aceptado
            t.append(t[-1] + h)
            y.append(y5)   # usar orden 5 porque es más preciso

        # Factor de corrección para el nuevo h
        # Deriva de la teoría del control de error
        h = 0.9 * h * (tol / err)**0.25 if err != 0 else h * 2

        # Evitar pasos demasiado pequeños
        if h < 1e-10:
            raise RuntimeError("El paso h se volvió demasiado pequeño")

    return np.array(t), np.array(y)


# ============================================================
# SOLUCIONES EXACTAS PARA COMPARAR
# ============================================================

def u1(t):
    return 2*np.exp(-t) - 2*np.exp(-2*t) + np.sin(t)

def u2(t):
    return -3*np.exp(-t) + 2*np.exp(-2*t)


# ============================================================
# RESOLVER EL PROBLEMA
# ============================================================

t, Y = rkf45(f, 0, 2, [0, -1], h0=0.1, tol=1e-6)

# Extraer y1 y y2
y1 = Y[:,0]
y2 = Y[:,1]


# ============================================================
# GRAFICAR
# ============================================================

plt.figure(figsize=(10,5))

plt.plot(t, y1, label="y1(t) RKF45")
plt.plot(t, y2, label="y2(t) RKF45")

# Soluciones exactas
tt = np.linspace(0,2,1000)
plt.plot(tt, u1(tt), '--', label="u1(t) exacta")
plt.plot(tt, u2(tt), '--', label="u2(t) exacta")

plt.title("Sistema resuelto con Runge–Kutta–Fehlberg (RKF45)")
plt.xlabel("t")
plt.ylabel("Soluciones")
plt.grid()
plt.legend()
plt.show()