# -*- coding: utf-8 -*-
"""Tarea 9.8

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W5A6YBHPA-OSjGUcMlsAQ2S3neb4ti5w
"""

import numpy as np
import matplotlib.pyplot as plt

# ---------------------------------------------------------
# Definir la función f(t, y) del problema
# ---------------------------------------------------------
def f(t, y):
    return t * np.exp(3*t) - 2*y


# ---------------------------------------------------------
# Método Adams-Moulton de 3 pasos
# Se requiere un método predictor para obtener w1, w2
# Usaremos Runge-Kutta 4 para obtener esos valores iniciales
# ---------------------------------------------------------

def runge_kutta4_step(t, y, h):
    """
    Un paso del método de Runge-Kutta de orden 4 (RK4)
    para obtener aproximaciones iniciales w1, w2 necesarias
    para Adams-Moulton de 3 pasos.
    """
    k1 = f(t, y)
    k2 = f(t + h/2, y + h*k1/2)
    k3 = f(t + h/2, y + h*k2/2)
    k4 = f(t + h,   y + h*k3)

    return y + h*(k1 + 2*k2 + 2*k3 + k4)/6


def adams_moulton_3step(a, b, y0, N):
    """
    Implementación del método Adams-Moulton de 3 pasos.

    Parámetros:
        a: inicio del intervalo
        b: fin del intervalo
        y0: condición inicial
        N: número de pasos

    Retorna:
        t: arreglo de tiempos
        w: aproximaciones numéricas del método
    """

    h = (b - a) / N
    t = np.linspace(a, b, N+1)
    w = np.zeros(N+1)

    # Condición inicial
    w[0] = y0

    # ---------------------------------------------------------
    # 1. Obtener w1 y w2 usando RK4 (necesarios para iniciar AM3)
    # ---------------------------------------------------------
    w[1] = runge_kutta4_step(t[0], w[0], h)
    w[2] = runge_kutta4_step(t[1], w[1], h)

    # ---------------------------------------------------------
    # 2. Aplicar Adams-Moulton de 3 pasos desde i = 2
    # ---------------------------------------------------------

    for i in range(2, N):
        # f en puntos anteriores
        f_i   = f(t[i],   w[i])
        f_im1 = f(t[i-1], w[i-1])
        f_im2 = f(t[i-2], w[i-2])

        # Término conocido con t_{i+1}
        t_ip1 = t[i+1]
        g_ip1 = t_ip1 * np.exp(3*t_ip1)  # parte que no depende de y

        # Fórmula explícita de w_{i+1} obtenida al despejar
        numerador = w[i] + (h/24)*(9*g_ip1 + 19*f_i - 5*f_im1 + f_im2)
        denominador = 1 + (3/4)*h   # proviene de mover terms de w_{i+1}

        w[i+1] = numerador / denominador

    return t, w



# ---------------------------------------------------------
# Ejecutar en el intervalo [0, 1] con N = 50 por ejemplo
# ---------------------------------------------------------
N = 50
t, w = adams_moulton_3step(0, 1, 0, N)

# ---------------------------------------------------------
# Solución exacta (para comparar)
# La solución exacta proviene de resolver la EDO lineal
# ---------------------------------------------------------
def y_exact(t):
    return (1/9)*(t*np.exp(3*t) - np.exp(3*t) + 1)  # solución calculada analíticamente

# Graficar
plt.plot(t, w, label="Adams-Moulton 3 pasos")
plt.plot(t, y_exact(t), '--', label="Solución exacta")
plt.xlabel("t")
plt.ylabel("y(t)")
plt.title("Método de Adams-Moulton de 3 pasos")
plt.legend()
plt.grid()
plt.show()
